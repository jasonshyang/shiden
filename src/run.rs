use std::time::Duration;

use tokio::{
    sync::{broadcast, mpsc},
    task::JoinSet,
};
use tokio_stream::StreamExt as _;
use tokio_util::sync::CancellationToken;

use crate::{
    metrics::BotMetrics,
    models::{Collector, Executor, InputBuilder, OneShot, StateEngine, Strategy},
};

/// Starts and orchestrates the entire trading bot system.
///
/// This is the main entry point that coordinates all components of the trading framework:
/// - **State Engines**: Maintain trading state and respond to data requests
/// - **Collectors**: Gather market data from various sources (exchanges)  
/// - **Executors**: Execute trading actions (place orders, etc.)
/// - **Strategy**: Core trading logic that evaluates data and generates actions
///
/// Data Flow:
/// 1. Collectors stream market events → Broadcast to all State Engines
/// 2. State Engines consume events and update internal state
/// 3. Strategy wakes up periodically, requests data from State Engines via OneShot channels
/// 4. State Engines respond with current data → Strategy builds input
/// 5. Strategy evaluates input → Generates actions
/// 6. Actions broadcast to Executors → Execute trading operations
///
/// # Type Parameters
///
/// * `S` - Strategy type that implements trading logic
/// * `E` - Event type for market data events
/// * `D` - Data type returned by state engines
/// * `I` - Input type consumed by strategy
/// * `A` - Action type generated by strategy
///
pub fn run_bot<S, E, D, I, A>(
    strategy: S,
    states: Vec<Box<dyn StateEngine<E, D>>>,
    collectors: Vec<Box<dyn Collector<E>>>,
    executors: Vec<Box<dyn Executor<A>>>,
    shutdown: CancellationToken,
) -> JoinSet<()>
where
    S: Strategy<D, I, A> + Send + Sync + 'static,
    E: Clone + Send + Sync + 'static,
    D: Send + Sync + 'static,
    I: Send + Sync + 'static,
    A: Clone + Send + Sync + 'static,
{
    let mut set = JoinSet::new();

    // Broadcast channels for distributing events and actions across the system
    let (event_tx, _) = broadcast::channel::<E>(1024);
    let (action_tx, _) = broadcast::channel::<A>(1024);

    // Spawn executor tasks - these listen for actions and execute them
    for executor in executors {
        tracing::info!("Starting executor: {}", executor.name());

        let mut action_rx = action_tx.subscribe();
        set.spawn(async move {
            while let Ok(action) = action_rx.recv().await {
                if let Err(e) = executor.execute(action).await {
                    tracing::error!(
                        "Error executing action in executor {}: {}",
                        executor.name(),
                        e
                    );
                    BotMetrics::record_error(executor.name());
                }
            }
            tracing::info!("Executor {} exited", executor.name());
        });
    }

    let mut request_txs = Vec::new();

    // Spawn state engine tasks - these maintain trading state and respond to data requests
    for mut state in states {
        tracing::info!("Starting state: {}", state.name());

        // Create channel for receiving request for this state engine
        let (request_tx, mut request_rx) = mpsc::unbounded_channel();

        // Store the request sender for the strategy to use
        request_txs.push(request_tx);

        let mut event_rx = event_tx.subscribe();
        let shutdown_signal = shutdown.clone();
        set.spawn(async move {
            if let Err(e) = state.sync_state().await {
                tracing::error!("Failed to sync state {}: {}", state.name(), e);
                return;
            }

            loop {
                tokio::select! {
                    biased;
                    // Handle shutdown signal
                    _ = shutdown_signal.cancelled() => {
                        tracing::info!("Shutdown signal received, exiting state {}", state.name());

                        if let Err(e) = state.on_shutdown() {
                            tracing::error!("Error during shutdown of state {}: {}", state.name(), e);
                        }
                        break;
                    }
                    // Handle data requests from strategy (priority)
                    request = request_rx.recv() => {
                        match request {
                            Some(request) => {
                                if let Err(e) = state.process_request(request) {
                                    tracing::error!("Error processing request in state {}: {}", state.name(), e);
                                    BotMetrics::record_error(state.name());
                                }
                            }
                            None => {
                                tracing::info!("Request channel for state {} is closed, exiting", state.name());
                                break;
                            }
                        }
                    }
                    // Handle market data events (lower priority)
                    event = event_rx.recv() => {
                        match event {
                            Ok(event) => {
                                if let Err(e) = state.process_event(event) {
                                    tracing::error!("Error processing event in state {}: {}", state.name(), e);
                                    BotMetrics::record_error(state.name());
                                }
                            }
                            Err(_) => {
                                tracing::info!("Event channel closed for state: {}, exiting", state.name());
                                break;
                            }
                        }
                    }
                }
            }

            tracing::info!("State {} exited", state.name());
        });
    }

    // Spawn the main strategy task - this is the core trading logic
    let shutdown_signal = shutdown.clone();
    set.spawn(async move {
        tracing::info!("Starting Strategy...");
        let mut interval = tokio::time::interval(Duration::from_millis(strategy.interval_ms()));

        'strategy: loop {
            tokio::select! {
                biased;
                // Handle shutdown signal
                _ = shutdown_signal.cancelled() => {
                    tracing::info!("Shutdown signal received, exiting strategy");
                    break 'strategy;
                }
                // Periodic evaluation of strategy
                _ = interval.tick() => {
                    // Request current data from all state engines in parallel
                    let mut handles = Vec::new();

                    for sender in &request_txs {
                        let (req, rx) = OneShot::new();
                        if let Err(e) = sender.send(req) {
                            tracing::warn!("Request channel for state is closed: {e}, exiting");
                            break 'strategy;
                        }

                        handles.push(tokio::spawn(rx));
                    }

                    // Build strategy input from collected state data
                    let mut input_builder = S::InputBuilder::default();

                    // Wait for all state responses and aggregate the data
                    // We should not need to timeout here because state engines process events and requests both
                    // synchronously, and requests are processed with priority over events
                    for res in futures::future::join_all(handles).await {
                        if let Ok(Ok(data)) = res {
                            input_builder.insert(data);
                        } else {
                            tracing::error!("Error receiving data from state request, exiting");
                            break 'strategy;
                        }
                    }

                    // Build the final input for strategy evaluation
                    let input = match input_builder.build() {
                        Ok(input) => input,
                        Err(e) => {
                            tracing::error!("Error building input: {}, skipping", e);
                            BotMetrics::record_error("strategy");
                            continue;
                        }
                    };

                    // Run strategy logic to generate trading actions
                    let actions = strategy.evaluate(input);

                    // Send all generated actions to executors
                    for action in actions {
                        if action_tx.send(action).is_err() {
                            tracing::error!("Action channel is closed, exiting");
                            break 'strategy;
                        }
                    }
                }
            }
        }

        tracing::info!("Strategy exited");
    });

    // Spawn collector tasks - these gather market data from external sources
    for collector in collectors {
        tracing::info!("Starting collector: {}", collector.name());
        let shutdown_signal = shutdown.clone();
        let event_tx = event_tx.clone();

        set.spawn(async move {
            let mut stream = collector.get_event_stream().await.unwrap();

            loop {
                tokio::select! {
                    biased;
                    // Handle shutdown signal
                    _ = shutdown_signal.cancelled() => {
                        tracing::info!("Shutdown signal received, exiting collector {}", collector.name());
                        break;
                    }
                    // Collect market data events
                    event = stream.next() => {
                        match event {
                            Some(event) => {
                                if event_tx.send(event).is_err() {
                                    tracing::info!("Internal event channel is closed, exiting collector {}", collector.name());
                                    break;
                                }
                            }
                            None => {
                                tracing::info!("Collector {} stream ended, exiting", collector.name());
                                break;
                            }
                        }
                    }
                }
            }

            tracing::info!("Collector {} exited", collector.name());
        });
    }

    set
}
